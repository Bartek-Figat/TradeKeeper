# docker build --no-cache
# docker-compose up -d
# docker-compose up -d -V
# docker ps
#docker exec -it some-mongo bash
#docker logs some-mongo
#docker-compose logs -f backend
#printenv | grep clientID
#docker-compose config
#docker-compose --version
# RUN npm install --only=production
#ARG NODE_ENV
# RUN if [  "$NODE_ENV" = "development"]; \
#         then npm install; \
#         else npm install --only=production \
# fi
# printenv
# docker volume ls
# docker volume prune
# docker exec -it node_docker_mongo_1 bash
# docker exec -it node_docker_mongo_1 mongo -u "root" -p "example"
# docker inspect container name
# docker network inspect container name


Docker Commands
docker build --no-cache
Description: Builds a Docker image from a Dockerfile without using any cached layers. This ensures that all steps are executed fresh, which is useful for ensuring the latest dependencies are installed.
2. docker ps
Description: Lists all running Docker containers. Useful for checking which containers are currently active.
3. docker exec -it <container_name> bash
Description: Opens an interactive terminal session inside a running container. Replace <container_name> with the actual name of the container.
docker logs <container_name>
Description: Fetches and displays the logs of a specified container. Useful for debugging and monitoring container output.
5. docker volume ls
Description: Lists all Docker volumes. Volumes are used to persist data generated by and used by Docker containers.
docker volume prune
Description: Removes all unused Docker volumes. This helps in cleaning up space by deleting volumes that are no longer referenced by any containers.
7. docker inspect <container_name>
Description: Returns detailed information about a container, including its configuration, state, and network settings.
docker network inspect <network_name>
Description: Provides detailed information about a Docker network, including connected containers and network settings.
Docker Compose Commands
1. docker-compose up -d
Description: Starts all services defined in a docker-compose.yaml file in detached mode (background). This is the standard way to start a multi-container application.
2. docker-compose up -d -V
Description: Starts services in detached mode and recreates anonymous volumes. Useful for ensuring that volumes are fresh.
docker-compose logs -f <service_name>
Description: Follows the logs of a specific service defined in the docker-compose.yaml. Replace <service_name> with the actual service name.
docker-compose config
Description: Validates and displays the configuration of the docker-compose.yaml file. Useful for checking for syntax errors and understanding the final configuration.
docker-compose --version
Description: Displays the version of Docker Compose installed. Useful for ensuring compatibility with Docker Compose files.
Environment and Build Commands
1. printenv | grep <variable_name>
Description: Prints environment variables and filters them by <variable_name>. Useful for checking if specific environment variables are set.
2. RUN npm install --only=production
Description: Installs only the production dependencies in a Node.js application. This is typically used in Dockerfiles to reduce image size.
ARG NODE_ENV
Description: Defines a build-time variable in a Dockerfile. This can be used to conditionally install dependencies based on the environment.
RUN if [ "$NODE_ENV" = "development" ]; then npm install; else npm install --only=production; fi
Description: A conditional statement in a Dockerfile to install all dependencies in development mode or only production dependencies otherwise.
5. printenv
Description: Prints all environment variables in the current shell session. Useful for debugging environment configurations.
These commands are essential for managing Docker containers and services, ensuring efficient development and deployment workflows.

name: Build and Push Docker Image

on:
  push:
    branches:
      - main # Change this to your default branch

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Log in to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v2
        with:
          context: .
          push: true
          tags: your-dockerhub-username/your-image-name:latest

      - name: Log out from Docker Hub
        run: docker logout
# Step 3: Set Up Docker Hub Credentials
# 1. Create a Docker Hub Access Token:
# Log in to Docker Hub.
# Go to Account Settings > Security.
# Create a new access token.
# 2. Add Secrets to GitHub:
# Go to your GitHub repository.
# Navigate to Settings > Secrets and variables > Actions.
# Add the following secrets:
# DOCKER_HUB_USERNAME: Your Docker Hub username.
# DOCKER_HUB_ACCESS_TOKEN: The access token you created.
# Explanation
# Triggers: The workflow triggers on a push to the main branch. You can adjust this to fit your branching strategy.
# Checkout: Uses the actions/checkout action to clone the repository.
# Docker Buildx: Sets up Docker Buildx, which is required for the docker/build-push-action.
# Login to Docker Hub: Uses the docker/login-action to authenticate with Docker Hub using the secrets you added.
# Build and Push: Uses the docker/build-push-action to build the Docker image and push it to Docker Hub. Replace your-dockerhub-username/your-image-name with your actual Docker Hub repository name.
# Logout: Logs out from Docker Hub after the push is complete.
# Final Steps
# Test the Workflow: Push a change to your main branch to trigger the workflow and verify that the image is built and pushed to Docker Hub.
# Monitor: Check the Actions tab in your GitHub repository to monitor the workflow execution and troubleshoot any issues.
